// File automatically generated by wgsl_to_wgpu in build.rs
// Changes made to this file will not be saved.
#![allow(dead_code, non_snake_case)]
pub mod bind_groups {
    #[derive(Debug)]
    pub struct BindGroup0(wgpu::BindGroup);
    #[derive(Debug)]
    pub struct BindGroupLayout0<'a> {
        pub constants: wgpu::BufferBinding<'a>,
        pub params: wgpu::BufferBinding<'a>,
    }
    const LAYOUT_DESCRIPTOR0: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
        label: Some("LayoutDescriptor0"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
        ],
    };
    impl BindGroup0 {
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&LAYOUT_DESCRIPTOR0)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: BindGroupLayout0) -> Self {
            let bind_group_layout = device.create_bind_group_layout(&LAYOUT_DESCRIPTOR0);
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                layout: &bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(bindings.constants),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(bindings.params),
                    },
                ],
                label: Some("BindGroup0"),
            });
            Self(bind_group)
        }
        pub fn set<P: SetBindGroup>(&self, pass: &mut P) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct BindGroup1(wgpu::BindGroup);
    #[derive(Debug)]
    pub struct BindGroupLayout1<'a> {
        pub particle_params: wgpu::BufferBinding<'a>,
        pub particle_counters: wgpu::BufferBinding<'a>,
        pub fbo_display: &'a wgpu::TextureView,
    }
    const LAYOUT_DESCRIPTOR1: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
        label: Some("LayoutDescriptor1"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Storage { read_only: false },
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Storage { read_only: false },
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::StorageTexture {
                    access: wgpu::StorageTextureAccess::WriteOnly,
                    format: wgpu::TextureFormat::Rgba8Unorm,
                    view_dimension: wgpu::TextureViewDimension::D2,
                },
                count: None,
            },
        ],
    };
    impl BindGroup1 {
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&LAYOUT_DESCRIPTOR1)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: BindGroupLayout1) -> Self {
            let bind_group_layout = device.create_bind_group_layout(&LAYOUT_DESCRIPTOR1);
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                layout: &bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::Buffer(bindings.particle_params),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Buffer(bindings.particle_counters),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::TextureView(bindings.fbo_display),
                    },
                ],
                label: Some("BindGroup1"),
            });
            Self(bind_group)
        }
        pub fn set<P: SetBindGroup>(&self, pass: &mut P) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct BindGroup2(wgpu::BindGroup);
    #[derive(Debug)]
    pub struct BindGroupLayout2<'a> {
        pub trail_read: &'a wgpu::TextureView,
        pub trail_write: &'a wgpu::TextureView,
    }
    const LAYOUT_DESCRIPTOR2: wgpu::BindGroupLayoutDescriptor = wgpu::BindGroupLayoutDescriptor {
        label: Some("LayoutDescriptor2"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::StorageTexture {
                    access: wgpu::StorageTextureAccess::ReadOnly,
                    format: wgpu::TextureFormat::R32Float,
                    view_dimension: wgpu::TextureViewDimension::D2,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::StorageTexture {
                    access: wgpu::StorageTextureAccess::WriteOnly,
                    format: wgpu::TextureFormat::R32Float,
                    view_dimension: wgpu::TextureViewDimension::D2,
                },
                count: None,
            },
        ],
    };
    impl BindGroup2 {
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&LAYOUT_DESCRIPTOR2)
        }
        pub fn from_bindings(device: &wgpu::Device, bindings: BindGroupLayout2) -> Self {
            let bind_group_layout = device.create_bind_group_layout(&LAYOUT_DESCRIPTOR2);
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                layout: &bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(bindings.trail_read),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::TextureView(bindings.trail_write),
                    },
                ],
                label: Some("BindGroup2"),
            });
            Self(bind_group)
        }
        pub fn set<P: SetBindGroup>(&self, pass: &mut P) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    #[derive(Debug, Copy, Clone)]
    pub struct BindGroups<'a> {
        pub bind_group0: &'a BindGroup0,
        pub bind_group1: &'a BindGroup1,
        pub bind_group2: &'a BindGroup2,
    }
    impl BindGroups<'_> {
        pub fn set<P: SetBindGroup>(&self, pass: &mut P) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
        }
    }
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::ComputePass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::RenderPass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::RenderBundleEncoder<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub fn set_bind_groups<P: bind_groups::SetBindGroup>(
    pass: &mut P,
    bind_group0: &bind_groups::BindGroup0,
    bind_group1: &bind_groups::BindGroup1,
    bind_group2: &bind_groups::BindGroup2,
) {
    bind_group0.set(pass);
    bind_group1.set(pass);
    bind_group2.set(pass);
}
pub mod compute {
    pub const CS_SETTER_WORKGROUP_SIZE: [u32; 3] = [16, 16, 1];
    pub fn create_cs_setter_pipeline(device: &wgpu::Device) -> wgpu::ComputePipeline {
        let module = super::create_shader_module(device);
        let layout = super::create_pipeline_layout(device);
        device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: Some("Compute Pipeline cs_setter"),
            layout: Some(&layout),
            module: &module,
            entry_point: Some("cs_setter"),
            compilation_options: Default::default(),
            cache: Default::default(),
        })
    }
    pub const CS_MOVE_WORKGROUP_SIZE: [u32; 3] = [256, 1, 1];
    pub fn create_cs_move_pipeline(device: &wgpu::Device) -> wgpu::ComputePipeline {
        let module = super::create_shader_module(device);
        let layout = super::create_pipeline_layout(device);
        device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: Some("Compute Pipeline cs_move"),
            layout: Some(&layout),
            module: &module,
            entry_point: Some("cs_move"),
            compilation_options: Default::default(),
            cache: Default::default(),
        })
    }
    pub const CS_DEPOSIT_WORKGROUP_SIZE: [u32; 3] = [16, 16, 1];
    pub fn create_cs_deposit_pipeline(device: &wgpu::Device) -> wgpu::ComputePipeline {
        let module = super::create_shader_module(device);
        let layout = super::create_pipeline_layout(device);
        device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: Some("Compute Pipeline cs_deposit"),
            layout: Some(&layout),
            module: &module,
            entry_point: Some("cs_deposit"),
            compilation_options: Default::default(),
            cache: Default::default(),
        })
    }
    pub const CS_DIFFUSION_WORKGROUP_SIZE: [u32; 3] = [16, 16, 1];
    pub fn create_cs_diffusion_pipeline(device: &wgpu::Device) -> wgpu::ComputePipeline {
        let module = super::create_shader_module(device);
        let layout = super::create_pipeline_layout(device);
        device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
            label: Some("Compute Pipeline cs_diffusion"),
            layout: Some(&layout),
            module: &module,
            entry_point: Some("cs_diffusion"),
            compilation_options: Default::default(),
            cache: Default::default(),
        })
    }
}
pub const ENTRY_CS_SETTER: &str = "cs_setter";
pub const ENTRY_CS_MOVE: &str = "cs_move";
pub const ENTRY_CS_DEPOSIT: &str = "cs_deposit";
pub const ENTRY_CS_DIFFUSION: &str = "cs_diffusion";
pub const SOURCE: &str = include_str!("compute_shader.wgsl");
pub fn create_shader_module(device: &wgpu::Device) -> wgpu::ShaderModule {
    let source = std::borrow::Cow::Borrowed(SOURCE);
    device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: None,
        source: wgpu::ShaderSource::Wgsl(source),
    })
}
pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
    device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: None,
        bind_group_layouts: &[
            &bind_groups::BindGroup0::get_bind_group_layout(device),
            &bind_groups::BindGroup1::get_bind_group_layout(device),
            &bind_groups::BindGroup2::get_bind_group_layout(device),
        ],
        push_constant_ranges: &[],
    })
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, bytemuck :: Pod, bytemuck :: Zeroable)]
pub struct Constants {
    pub width: u32,
    pub height: u32,
    pub reset_value: u32,
    pub deposit_factor: f32,
    pub decay_factor: f32,
}
const _: () = assert!(
    std::mem::size_of::<Constants>() == 20,
    "size of Constants does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(Constants, width) == 0,
    "offset of Constants.width does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(Constants, height) == 4,
    "offset of Constants.height does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(Constants, reset_value) == 8,
    "offset of Constants.reset_value does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(Constants, deposit_factor) == 12,
    "offset of Constants.deposit_factor does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(Constants, decay_factor) == 16,
    "offset of Constants.decay_factor does not match WGSL"
);
pub const LIMIT: f32 = 100f32;
pub const PI: f32 = 3.1415927f32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, bytemuck :: Pod, bytemuck :: Zeroable)]
pub struct PointSettings {
    pub default_scaling_factor: f32,
    pub sd_base: f32,
    pub sd_exponent: f32,
    pub sd_amplitude: f32,
    pub sa_base: f32,
    pub sa_exponent: f32,
    pub sa_amplitude: f32,
    pub ra_base: f32,
    pub ra_exponent: f32,
    pub ra_amplitude: f32,
    pub md_base: f32,
    pub md_exponent: f32,
    pub md_amplitude: f32,
    pub sensor_bias_1: f32,
    pub sensor_bias_2: f32,
}
const _: () = assert!(
    std::mem::size_of::<PointSettings>() == 60,
    "size of PointSettings does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, default_scaling_factor) == 0,
    "offset of PointSettings.default_scaling_factor does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sd_base) == 4,
    "offset of PointSettings.sd_base does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sd_exponent) == 8,
    "offset of PointSettings.sd_exponent does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sd_amplitude) == 12,
    "offset of PointSettings.sd_amplitude does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sa_base) == 16,
    "offset of PointSettings.sa_base does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sa_exponent) == 20,
    "offset of PointSettings.sa_exponent does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sa_amplitude) == 24,
    "offset of PointSettings.sa_amplitude does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, ra_base) == 28,
    "offset of PointSettings.ra_base does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, ra_exponent) == 32,
    "offset of PointSettings.ra_exponent does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, ra_amplitude) == 36,
    "offset of PointSettings.ra_amplitude does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, md_base) == 40,
    "offset of PointSettings.md_base does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, md_exponent) == 44,
    "offset of PointSettings.md_exponent does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, md_amplitude) == 48,
    "offset of PointSettings.md_amplitude does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sensor_bias_1) == 52,
    "offset of PointSettings.sensor_bias_1 does not match WGSL"
);
const _: () = assert!(
    std::mem::offset_of!(PointSettings, sensor_bias_2) == 56,
    "offset of PointSettings.sensor_bias_2 does not match WGSL"
);

